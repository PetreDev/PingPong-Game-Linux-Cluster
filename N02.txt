#!/bin/bash
# =============================================================================
# N02 - Linux Cluster SSH Environment Setup Script
# =============================================================================
# Description:
# This script creates N Docker containers based on the N01 SSH environment setup,
# configures networking so each container has its own IP address, enables SSH
# communication between all instances, and demonstrates connectivity from:
# - Host (computer 0) to each container (computer 1)
# - Each container to all other containers (computer 2, 3, ..., N)
# Uses parallel-ssh to efficiently test all combinations.
#
# Usage: ./N02.txt [N]
#   N: Number of containers to create (default: 3)
#
# Author: Based on N01 exercise requirements
# License: CC BY-NC 4.0
# =============================================================================

# Set default number of containers if not provided
N=${1:-3}

# Validate N is a positive integer
if ! [[ "$N" =~ ^[0-9]+$ ]] || [ "$N" -lt 1 ]; then
    echo "Error: N must be a positive integer"
    exit 1
fi

echo "=== N02 Linux Cluster SSH Environment Setup ==="
echo "Creating $N container instances..."
echo ""

time_start=$(date +%s.%N)

# =============================================================================
# Step 1: Generate SSH key pair for passwordless authentication
# =============================================================================
# This key will be shared across all containers for SSO (Single Sign-On)
# =============================================================================

echo -e "\033[92mStep 1: \033[100mGenerating RSA keys for passwordless SSH.\033[0m"

KEY_DIR="keydir"
PRIVATE_KEY="${KEY_DIR}/my_key"
PUBLIC_KEY="${KEY_DIR}/my_key.pub"

# Create key directory if it doesn't exist
mkdir -p "${KEY_DIR}"
chmod 700 "${KEY_DIR}"

# Generate passwordless RSA key if it doesn't exist
if [ ! -f "${PRIVATE_KEY}" ]; then
    ssh-keygen -t rsa -b 4096 -f "${PRIVATE_KEY}" -N "" -C "ssh-cluster-key"
fi

chmod 600 "${PRIVATE_KEY}"
chmod 644 "${PUBLIC_KEY}"

echo "SSH keys ready."

# =============================================================================
# Step 2: Create Dockerfile
# =============================================================================
# Creates a Dockerfile that sets up Ubuntu with OpenSSH server and parallel-ssh
# without modifying SSH daemon configuration (uses Ubuntu defaults)
# =============================================================================

echo -e "\n\033[92mStep 2: \033[100mCreating Dockerfile.\033[0m"

cat > Dockerfile << 'DOCKERFILE_EOF'
FROM ubuntu:22.04

# Prevent interactive prompts during apt installs
ENV DEBIAN_FRONTEND=noninteractive

# Install OpenSSH server, sudo, and parallel-ssh
RUN apt-get update && \
    apt-get install -y openssh-server sudo pssh && \
    mkdir -p /var/run/sshd && \
    rm -rf /var/lib/apt/lists/*

# Create non-root user with home directory and SSH folder
RUN useradd -m -s /bin/bash student && \
    mkdir -p /home/student/.ssh && \
    chown -R student:student /home/student

# Setup SSH directories (relying on Ubuntu 22.04 default SSH configuration)
RUN mkdir -p /root/.ssh

# Generate SSH host keys
RUN ssh-keygen -A

# Expose port 22 for SSH
EXPOSE 22

# Start the SSH daemon in foreground when container runs
CMD ["/usr/sbin/sshd", "-D"]
DOCKERFILE_EOF

echo "Dockerfile created."

# =============================================================================
# Step 3: Build Docker image
# =============================================================================
# Builds the Docker image with all necessary SSH components
# =============================================================================

echo -e "\n\033[92mStep 3: \033[100mBuilding Docker image.\033[0m"

IMAGE_NAME="linux-ssh-cluster"

# Stop and remove any existing containers with our naming pattern
docker ps -a --filter "name=ssh-container-" --format "{{.ID}}" | xargs -r docker rm -f 2>/dev/null || true

# Build the image
docker build -t "${IMAGE_NAME}" . > /dev/null 2>&1

if [ $? -eq 0 ]; then
    echo "Docker image '${IMAGE_NAME}' built successfully."
else
    echo "Error: Failed to build Docker image"
    exit 1
fi

# =============================================================================
# Step 4: Create custom Docker network
# =============================================================================
# Creates a bridge network so containers can communicate with each other
# =============================================================================

echo -e "\n\033[92mStep 4: \033[100mCreating Docker network.\033[0m"

NETWORK_NAME="ssh-cluster-net"

# First, stop and remove any containers that might be using this network
echo "  Cleaning up any existing containers using the network..."
docker ps -a --filter "name=ssh-container-" --format "{{.ID}}" | while read CID; do
    docker stop "$CID" > /dev/null 2>&1
    docker rm "$CID" > /dev/null 2>&1
done || true

# Remove existing network if it exists
echo "  Removing existing network if present..."
if docker network inspect "${NETWORK_NAME}" > /dev/null 2>&1; then
    # Disconnect any containers still connected
    docker network inspect "${NETWORK_NAME}" --format '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null | \
        tr ' ' '\n' | grep -v '^$' | while read CONTAINER_NAME; do
            docker network disconnect -f "${NETWORK_NAME}" "${CONTAINER_NAME}" > /dev/null 2>&1 || true
        done
    docker network rm "${NETWORK_NAME}" > /dev/null 2>&1 || true
    sleep 2
fi

# Create new bridge network with subnet for predictable IPs
echo "  Creating network with subnet 172.20.0.0/16..."
NETWORK_ERROR=$(docker network create --subnet=172.20.0.0/16 "${NETWORK_NAME}" 2>&1)
NETWORK_EXIT_CODE=$?

if [ $NETWORK_EXIT_CODE -eq 0 ]; then
    echo "Docker network '${NETWORK_NAME}' created successfully."
else
    # Check if it's a subnet conflict - try a different subnet
    if echo "$NETWORK_ERROR" | grep -q "already exists\|overlaps"; then
        echo "  Subnet conflict detected, trying alternative subnet..."
        # Try alternative subnet
        NETWORK_NAME_ALT="ssh-cluster-net-alt"
        if docker network inspect "${NETWORK_NAME_ALT}" > /dev/null 2>&1; then
            docker network rm "${NETWORK_NAME_ALT}" > /dev/null 2>&1 || true
            sleep 1
        fi
        
        if docker network create --subnet=172.21.0.0/16 "${NETWORK_NAME_ALT}" > /dev/null 2>&1; then
            NETWORK_NAME="${NETWORK_NAME_ALT}"
            echo "Docker network '${NETWORK_NAME}' created with alternative subnet."
        else
            # Last resort: create without specifying subnet
            echo "  Creating network without custom subnet..."
            if docker network create "${NETWORK_NAME}" > /dev/null 2>&1; then
                echo "Docker network '${NETWORK_NAME}' created (using default subnet)."
            else
                echo "Error: Failed to create Docker network"
                echo "Error details: $NETWORK_ERROR"
                exit 1
            fi
        fi
    else
        # If creation fails, check if network already exists
        if docker network inspect "${NETWORK_NAME}" > /dev/null 2>&1; then
            echo "Docker network '${NETWORK_NAME}' already exists, reusing it."
        else
            echo "Error: Failed to create Docker network"
            echo "Error details: $NETWORK_ERROR"
            exit 1
        fi
    fi
fi

# =============================================================================
# Step 5: Create N containers with unique IP addresses
# =============================================================================
# Creates N containers, each with its own IP address on the custom network
# =============================================================================

echo -e "\n\033[92mStep 5: \033[100mCreating $N containers with unique IP addresses.\033[0m"

CONTAINER_IDS=()
CONTAINER_IPS=()
CONTAINER_NAMES=()

# Check if network has a custom subnet (for IP assignment)
NETWORK_SUBNET=$(docker network inspect "${NETWORK_NAME}" --format '{{range .IPAM.Config}}{{.Subnet}}{{end}}' 2>/dev/null)
HAS_CUSTOM_SUBNET=false

# Determine base IP from network subnet if available
if echo "$NETWORK_SUBNET" | grep -q "172.20\|172.21"; then
    HAS_CUSTOM_SUBNET=true
    if echo "$NETWORK_SUBNET" | grep -q "172.20"; then
        BASE_IP=172.20.0
    else
        BASE_IP=172.21.0
    fi
fi

for i in $(seq 1 $N); do
    CONTAINER_NAME="ssh-container-${i}"
    
    # Try to assign specific IP if we have a custom subnet
    if [ "$HAS_CUSTOM_SUBNET" = true ]; then
        CONTAINER_IP="${BASE_IP}.$((i + 1))"  # Start from .2, .3, .4, etc.
        # Run container with specific IP address
        CID=$(docker run -d \
            --name "${CONTAINER_NAME}" \
            --network "${NETWORK_NAME}" \
            --ip "${CONTAINER_IP}" \
            "${IMAGE_NAME}" 2>&1)
        RUN_EXIT_CODE=$?
    else
        # Run container without specific IP (Docker will assign automatically)
        CID=$(docker run -d \
            --name "${CONTAINER_NAME}" \
            --network "${NETWORK_NAME}" \
            "${IMAGE_NAME}" 2>&1)
        RUN_EXIT_CODE=$?
    fi
    
    if [ $RUN_EXIT_CODE -eq 0 ]; then
        # Extract container ID (first 12 chars)
        CID_SHORT=$(echo "$CID" | head -c 12)
        CONTAINER_IDS+=("${CID_SHORT}")
        CONTAINER_NAMES+=("${CONTAINER_NAME}")
        
        # Get actual IP address assigned to container
        if [ "$HAS_CUSTOM_SUBNET" = true ] && [ $RUN_EXIT_CODE -eq 0 ]; then
            ACTUAL_IP="${CONTAINER_IP}"
        else
            # Get IP from Docker inspect
            ACTUAL_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "${CONTAINER_NAME}" 2>/dev/null)
        fi
        
        CONTAINER_IPS+=("${ACTUAL_IP}")
        echo "  Created container ${i}/${N}: ${CONTAINER_NAME} (IP: ${ACTUAL_IP}, ID: ${CID_SHORT})"
    else
        echo "Error: Failed to create container ${i}"
        echo "Error details: $CID"
        exit 1
    fi
done

# Wait for SSH daemons to start
echo "Waiting for SSH daemons to start..."
sleep 5

# =============================================================================
# Step 6: Setup SSH keys in all containers
# =============================================================================
# Copies the public key to authorized_keys and private key for client use
# =============================================================================

echo -e "\n\033[92mStep 6: \033[100mSetting up SSH keys in all containers.\033[0m"

for i in $(seq 0 $((N - 1))); do
    IP="${CONTAINER_IPS[$i]}"
    NAME="${CONTAINER_NAMES[$i]}"
    
    # Copy public key to root's authorized_keys
    docker cp "${PUBLIC_KEY}" "${NAME}:/root/.ssh/authorized_keys" > /dev/null 2>&1

    # Copy private key for client use (for pssh)
    docker cp "${PRIVATE_KEY}" "${NAME}:/root/.ssh/my_key" > /dev/null 2>&1

    # Fix ownership and permissions inside container for root user
    docker exec "${NAME}" chown -R root:root /root/.ssh > /dev/null 2>&1
    docker exec "${NAME}" chmod 700 /root/.ssh > /dev/null 2>&1
    docker exec "${NAME}" chmod 600 /root/.ssh/authorized_keys > /dev/null 2>&1
    docker exec "${NAME}" chmod 600 /root/.ssh/my_key > /dev/null 2>&1
    docker exec "${NAME}" chmod 644 /root/.ssh/known_hosts > /dev/null 2>&1
    
    # Also setup for student user
    docker exec "${NAME}" mkdir -p /home/student/.ssh > /dev/null 2>&1
    docker cp "${PUBLIC_KEY}" "${NAME}:/home/student/.ssh/authorized_keys" > /dev/null 2>&1
    docker exec "${NAME}" chown -R student:student /home/student/.ssh > /dev/null 2>&1
    docker exec "${NAME}" chmod 700 /home/student/.ssh > /dev/null 2>&1
    docker exec "${NAME}" chmod 600 /home/student/.ssh/authorized_keys > /dev/null 2>&1
done

echo "SSH keys configured in all containers."

# =============================================================================
# Step 7: Scan and add SSH host keys to known_hosts
# =============================================================================
# Collects SSH fingerprints from all containers to avoid host key verification prompts
# =============================================================================

echo -e "\n\033[92mStep 7: \033[100mScanning SSH host keys.\033[0m"

KNOWN_HOSTS_FILE="known_hosts"
> "${KNOWN_HOSTS_FILE}"  # Clear/create known_hosts file

for IP in "${CONTAINER_IPS[@]}"; do
    # Remove from user's known_hosts if exists
    ssh-keygen -f "${HOME}/.ssh/known_hosts" -R "${IP}" 2>/dev/null || true
    
    # Scan and add to our known_hosts file
    ssh-keyscan -H "${IP}" 2>/dev/null >> "${KNOWN_HOSTS_FILE}" || true
done

# Copy known_hosts to all containers
for i in $(seq 0 $((N - 1))); do
    NAME="${CONTAINER_NAMES[$i]}"
    docker cp "${KNOWN_HOSTS_FILE}" "${NAME}:/root/.ssh/known_hosts" > /dev/null 2>&1
    docker cp "${KNOWN_HOSTS_FILE}" "${NAME}:/home/student/.ssh/known_hosts" > /dev/null 2>&1
done

echo "SSH host keys scanned and distributed."

# =============================================================================
# Step 8: Test connections from host (computer 0) to each container (computer 1)
# =============================================================================
# Demonstrates SSH connectivity from the host machine to each container
# =============================================================================

echo -e "\n\033[92mStep 8: \033[100mTesting connections from host (computer 0) to containers.\033[0m"
echo -e "\033[33mConnecting from host to each container and running 'hostname -I':\033[0m"
echo ""

for IP in "${CONTAINER_IPS[@]}"; do
    echo -n "  Host -> ${IP}: "
    ssh -i "${PRIVATE_KEY}" \
        -o StrictHostKeyChecking=no \
        -o ConnectTimeout=5 \
        root@"${IP}" \
        "hostname -I" 2>/dev/null || echo "FAILED"
done

# =============================================================================
# Step 9: Test connections from each container to all other containers using parallel-ssh
# =============================================================================
# Uses parallel-ssh to efficiently test all container-to-container connections
# This demonstrates all combinations: container i -> container j (where i != j)
# =============================================================================

echo -e "\n\033[92mStep 9: \033[100mTesting all container-to-container connections using parallel-ssh.\033[0m"
echo -e "\033[33mFor each container, connecting to all other containers and running 'hostname -I':\033[0m"
echo ""

# Build host list string for pssh (space-separated IPs)
ALL_IPS_STR=$(IFS=' '; echo "${CONTAINER_IPS[*]}")

for i in $(seq 0 $((N - 1))); do
    SOURCE_IP="${CONTAINER_IPS[$i]}"
    SOURCE_NAME="${CONTAINER_NAMES[$i]}"
    
    # Build list of target IPs (all except the source)
    TARGET_IPS=()
    for j in $(seq 0 $((N - 1))); do
        if [ $j -ne $i ]; then
            TARGET_IPS+=("${CONTAINER_IPS[$j]}")
        fi
    done
    
    TARGET_IPS_STR=$(IFS=' '; echo "${TARGET_IPS[*]}")
    
    echo -e "\033[91mContainer ${SOURCE_IP}\033[0m connecting to all others:"
    
    # Use parallel-ssh from within the container to connect to all other containers
    ssh -i "${PRIVATE_KEY}" \
        -o StrictHostKeyChecking=no \
        -o ConnectTimeout=5 \
        root@"${SOURCE_IP}" \
        "parallel-ssh -i -x \"-i /root/.ssh/my_key\" -H \"${TARGET_IPS_STR}\" hostname -I" 2>/dev/null | \
        sed 's/^/  /' || echo "  Connection failed"
    
    echo ""
done

# =============================================================================
# Step 10: Summary and connection information
# =============================================================================
# Displays summary information and connection instructions
# =============================================================================

echo -e "\033[92mStep 10: \033[100mSummary.\033[0m"
echo ""
echo "Created $N containers:"
for i in $(seq 0 $((N - 1))); do
    echo "  Container $((i + 1)): ${CONTAINER_NAMES[$i]} (IP: ${CONTAINER_IPS[$i]}, ID: ${CONTAINER_IDS[$i]:0:12})"
done
echo ""
echo "Total connections tested:"
echo "  Host -> Containers: $N"
echo "  Container -> Container: $((N * (N - 1)))"
echo "  Total: $((N + N * (N - 1))) = $((N * N))"
echo ""

# =============================================================================
# Step 11: Cleanup (optional - commented out by default)
# =============================================================================
# Uncomment the cleanup section below to automatically remove containers and network
# =============================================================================

# Uncomment to enable automatic cleanup:
# echo -e "\n\033[92mStep 11: \033[100mCleaning up...\033[0m"
# for CID in "${CONTAINER_IDS[@]}"; do
#     docker stop "${CID}" > /dev/null 2>&1
#     docker rm "${CID}" > /dev/null 2>&1
# done
# docker network rm "${NETWORK_NAME}" > /dev/null 2>&1
# docker image rm "${IMAGE_NAME}" > /dev/null 2>&1
# rm -rf "${KEY_DIR}" "${KNOWN_HOSTS_FILE}" Dockerfile
# echo "Cleanup complete."

time_stop=$(date +%s.%N)
time_duration=$(echo "$time_stop - $time_start" | bc)
echo -e "\nExecution duration: ${time_duration} seconds"
echo ""
echo "=== Setup Complete ==="
echo ""
echo "To manually connect to a container:"
echo "  ssh -i ${PRIVATE_KEY} root@<container-ip>"
echo ""
echo "To cleanup manually, run:"
echo "  docker stop \$(docker ps -q --filter 'name=ssh-container-')"
echo "  docker rm \$(docker ps -aq --filter 'name=ssh-container-')"
echo "  docker network rm ${NETWORK_NAME}"
echo "  docker image rm ${IMAGE_NAME}"

exit 0

# =============================================================================
# ACTUAL OUTPUT (Example for N=3)
# =============================================================================
#
# === N02 Linux Cluster SSH Environment Setup ===
# Creating 3 container instances...
#
# Step 1: Generating RSA keys for passwordless SSH.
# SSH keys ready.
#
# Step 2: Creating Dockerfile.
# Dockerfile created.
#
# Step 3: Building Docker image.
# Docker image 'linux-ssh-cluster' built successfully.
#
# Step 4: Creating Docker network.
#   Cleaning up any existing containers using the network...
#   Removing existing network if present...
#   Creating network with subnet 172.20.0.0/16...
#   Subnet conflict detected, trying alternative subnet...
# Docker network 'ssh-cluster-net-alt' created with alternative subnet.
#
# Step 5: Creating 3 containers with unique IP addresses.
#   Created container 1/3: ssh-container-1 (IP: 172.21.0.2, ID: c4a4f2903976)
#   Created container 2/3: ssh-container-2 (IP: 172.21.0.3, ID: 09efd8a0fbac)
#   Created container 3/3: ssh-container-3 (IP: 172.21.0.4, ID: 1f6c9066b234)
# Waiting for SSH daemons to start...
#
# Step 6: Setting up SSH keys in all containers.
# SSH keys configured in all containers.
#
# Step 7: Scanning SSH host keys.
# SSH host keys scanned and distributed.
#
# Step 8: Testing connections from host (computer 0) to containers.
# Connecting from host to each container and running 'hostname -I':
#
#   Host -> 172.21.0.2: 172.21.0.2
#   Host -> 172.21.0.3: 172.21.0.3
#   Host -> 172.21.0.4: 172.21.0.4
#
# Step 9: Testing all container-to-container connections using parallel-ssh.
# For each container, connecting to all other containers and running 'hostname -I':
#
# Container 172.21.0.2 connecting to all others:
#   [1] 23:14:04 [SUCCESS] 172.21.0.3
#   172.21.0.3
#   [2] 23:14:04 [SUCCESS] 172.21.0.4
#   172.21.0.4
#
# Container 172.21.0.3 connecting to all others:
#   [1] 23:14:04 [SUCCESS] 172.21.0.2
#   172.21.0.2
#   [2] 23:14:04 [SUCCESS] 172.21.0.4
#   172.21.0.4
#
# Container 172.21.0.4 connecting to all others:
#   [1] 23:14:05 [SUCCESS] 172.21.0.2
#   172.21.0.2
#   [2] 23:14:05 [SUCCESS] 172.21.0.3
#   172.21.0.3
#
# Step 10: Summary.
#
# Created 3 containers:
#   Container 1: ssh-container-1 (IP: 172.21.0.2, ID: c4a4f2903976)
#   Container 2: ssh-container-2 (IP: 172.21.0.3, ID: 09efd8a0fbac)
#   Container 3: ssh-container-3 (IP: 172.21.0.4, ID: 1f6c9066b234)
#
# Total connections tested:
#   Host -> Containers: 3
#   Container -> Container: 6
#   Total: 9 = 9
#
# Execution duration: 12.779335185 seconds
#
# === Setup Complete ===
#
# To manually connect to a container:
#   ssh -i keydir/my_key root@<container-ip>
#
# To cleanup manually, run:
#   docker stop $(docker ps -q --filter 'name=ssh-container-')
#   docker rm $(docker ps -aq --filter 'name=ssh-container-')
#   docker network rm ssh-cluster-net-alt
#   docker image rm linux-ssh-cluster
#
# =============================================================================
# STEP-BY-STEP DESCRIPTION 
# =============================================================================
#
# STEP 1: Generating SSH keys
# ----------
# The script generates an RSA SSH key pair (public and private) for passwordless
# authentication. These keys will be shared across all containers, enabling
# Single Sign-On (SSO) functionality.
#
# STEP 2: Creating Dockerfile
# ----------
# Creates a Dockerfile that defines a Docker image with Ubuntu 22.04, OpenSSH server
# and parallel-ssh tool. The Dockerfile also sets up the 'student' user and
# configures SSH to work with public keys.
#
# STEP 3: Building Docker image
# ----------
# Builds the Docker image from the Dockerfile. This image contains all necessary
# components for SSH communication between containers.
#
# STEP 4: Creating Docker network
# ----------
# Creates a custom Docker bridge network with a specified subnet (172.20.0.0/16).
# This allows each container to receive its own unique IP address and communicate
# with other containers in the same network.
#
# STEP 5: Creating N containers with unique IP addresses
# ----------
# Creates N Docker containers, each assigned an IP address from the subnet.
# IP addresses are assigned sequentially (172.20.0.2, 172.20.0.3, ...).
# Each container also receives a unique name (ssh-container-1, ssh-container-2, ...).
#
# STEP 6: Setting up SSH keys in all containers
# ----------
# Copies the public SSH key to the authorized_keys file of each container
# (for both root and student users). Also copies the private key to the container
# for use with the parallel-ssh tool. Sets correct permissions for SSH files.
#
# STEP 7: Scanning and adding SSH host keys
# ----------
# Collects SSH fingerprints from all containers and saves them in a known_hosts file.
# This prevents interactive prompts for host verification during SSH connections.
# The known_hosts file is copied to all containers.
#
# STEP 8: Testing connections from host (computer 0) to containers (computer 1)
# ----------
# Demonstrates SSH connectivity from the host machine to each container.
# For each container, executes the 'hostname -I' command which displays the container's IP addresses.
# This confirms that communication from host to containers is successful.
#
# STEP 9: Testing connections between containers using parallel-ssh
# ----------
# Uses the parallel-ssh tool to efficiently test all combinations of connections
# between containers. For each container (i), connects to all other containers
# (j, where j != i) and executes the 'hostname -I' command.
# This demonstrates all possible combinations of connections between containers.
# For N=3 containers, this is 3 × 2 = 6 inter-container connections.
# For N=10 containers, this would be 10 × 9 = 90 connections.
#
# STEP 10: Summary
# ----------
# Displays a summary of created containers, their IP addresses, and the total
# number of tested connections. For N containers, the total number of connections is N²
# (N connections from host + N×(N-1) inter-container connections).
#
# STEP 11: Cleanup (optional)
# ----------
# Optional step to automatically remove all containers, network, and image.
# Commented out by default so containers remain for manual testing.
#
# =============================================================================
# TECHNICAL NOTES
# =============================================================================
#
# - The script uses Docker's bridge networking with custom subnet for predictable IPs
# - All containers share the same SSH key pair for SSO functionality
# - parallel-ssh (Ubuntu package) is used for efficient parallel SSH connections
# - Ubuntu 22.04 is used for compatibility with OpenSSH and parallel-ssh
# - The script relies on Ubuntu 22.04 default SSH configuration (no sshd_config modifications)
# - For N=3: 3 host->container + 6 container->container = 9 total connections
# - For N=10: 10 host->container + 90 container->container = 100 total connections
# - For N=500: 500 host->container + 249500 container->container = 250000 total connections
#
# =============================================================================

